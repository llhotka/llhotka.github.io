[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Ladislav Lhotka",
    "section": "",
    "text": "Welcome to my blog! I am a retired ICT researcher, developer and manager. In 1990s I participated in early developments of the Czech academic Internet (CESNET project), and started the campus network of the University of South Bohemia and Biology Centre CAS in České Budějovice.\nSince 2006 I’ve been actively involved in NETCONF, NETMOD and DNSOP working groups of the Internet Engineering Task Force (IETF). I authored or co-authored 8 RFC standards.\nAn open-ended list of topics that I might possibly write about includes home automation and energy management, electromobility, photovoltaics, programming, personal productivity tools, data crunching, technical and scientific publishing, music, golf, …\nThis blog site has been built using the Quarto framework and GitHub Pages."
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "Literate Home Assistant Configuration\n\n\n\n\n\nMay 5, 2025\n\n\n\n\n\n\n\nMyBox and Home Assistant\n\n\n\n\n\nOct 29, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/literate-ha-config/index.html",
    "href": "posts/literate-ha-config/index.html",
    "title": "Literate Home Assistant Configuration",
    "section": "",
    "text": "Home Assistant is a leading open-source platform for home automation. My first experiments with it date back to 2022, and my evolution path since then might have been, I guess, quite typical. I started small but kept adding new smart devices, automations and all that stuff. Before long I realized that my configuration has become complex and unwieldy. I found it rather difficult to work with definitions scattered across the front-end UI pages and/or YAML files, despite all the great improvements to the user interface that have been introduced recently.\nI spent some time considering my requirements and came up with the following list:\n\nSource code management applied to all YAML definitions, perhaps except trivial ones.\nRelated definitions across all categories, such as automations, scripts or template sensors, should be kept together.\nIt should be possible to document definitions well beyond what’s reasonable to have as object descriptions.\nI want to keep an archive of scripts, template sensors etc. that needn’t be necessarily configured in my Home Assistant server.\n\nAs it turned out, with the toolset that I’ve been using for decades, especially Git, Emacs and Org mode, it was possible to achieve the above goals pretty easily. I realize that my solution, which I call literate configuration, isn’t for everybody but, after two years of almost daily usage, I must say that it works almost perfectly and has already saved me a lot of time and trouble."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#introduction",
    "href": "posts/literate-ha-config/index.html#introduction",
    "title": "Literate Home Assistant Configuration",
    "section": "",
    "text": "Home Assistant is a leading open-source platform for home automation. My first experiments with it date back to 2022, and my evolution path since then might have been, I guess, quite typical. I started small but kept adding new smart devices, automations and all that stuff. Before long I realized that my configuration has become complex and unwieldy. I found it rather difficult to work with definitions scattered across the front-end UI pages and/or YAML files, despite all the great improvements to the user interface that have been introduced recently.\nI spent some time considering my requirements and came up with the following list:\n\nSource code management applied to all YAML definitions, perhaps except trivial ones.\nRelated definitions across all categories, such as automations, scripts or template sensors, should be kept together.\nIt should be possible to document definitions well beyond what’s reasonable to have as object descriptions.\nI want to keep an archive of scripts, template sensors etc. that needn’t be necessarily configured in my Home Assistant server.\n\nAs it turned out, with the toolset that I’ve been using for decades, especially Git, Emacs and Org mode, it was possible to achieve the above goals pretty easily. I realize that my solution, which I call literate configuration, isn’t for everybody but, after two years of almost daily usage, I must say that it works almost perfectly and has already saved me a lot of time and trouble."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#code-blocks-and-yaml-in-emacs",
    "href": "posts/literate-ha-config/index.html#code-blocks-and-yaml-in-emacs",
    "title": "Literate Home Assistant Configuration",
    "section": "Code blocks and YAML in Emacs",
    "text": "Code blocks and YAML in Emacs\nOne of the less frequently used features of Org mode is the ability to intersperse text with code blocks enclosed in #+begin_src &lt;language&gt; and #+end_src, where &lt;language&gt; identifies the programming language in which the code block is written. If such a block is opened for editing (the default key combination for this is Ctrl-C '), Emacs activates the editing mode that’s available for the given language, and then inserts the edited code back to the Org source file.\nEven though Org supports all common languages, YAML isn’t among them – maybe because it really isn’t a programming language. It was however quite easy to implement support for YAML code blocks by modifying the provided Emacs Lisp template. The resulting module ob-yaml.el is available on GitHub and can be loaded in Emacs as usual."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#literate-programming",
    "href": "posts/literate-ha-config/index.html#literate-programming",
    "title": "Literate Home Assistant Configuration",
    "section": "Literate programming",
    "text": "Literate programming\nThe term literate programming was coined by Donald Knuth in 1984 as a way for developing computer programs as pieces of literature that humans can easily read and enjoy. He then used this programming method for developing the TeX typesetting system that many of us still use. The Org mode uses the noweb implementation of literate programming. Two of its features are important for our purposes:\n\nDesignated code blocks can be “tangled“ – extracted from the Org source and pasted sequentially into one or more files.\nA named code block can be referred to from other code blocks by using its name enclosed in &lt;&lt; and &gt;&gt;. The code from the referred block is then inserted in the referring block when the latter is tangled.\n\nThe former approach is simpler and useful for putting together chunks that are at the top level of YAML hierarchy, for example\n#+begin_src yaml :tangle customizations.yaml\n  sensor.ecovolter_total_energy:\n    device_class: energy\n#+end_src\nChunks with the same value of the :tangle parameter are collected, in the order as they appear in the source Org file, in the specified file (customizations.yaml for the example above).\nYAML chunks to be placed somewhere deeper in the hierarchy can be handled using the second approach (noweb references). One has to write a skeleton configuration file, and then refer to individual chunks from it. For instance, the configuration file for RESTful integration look like this (abridged):\n#+begin_src yaml :tangle rest.yaml\n  - resource: !secret ecovolter_get_url\n    scan_interval: 5\n    verify_ssl: true\n    headers:\n      X-API-KEY: !secret ecovolter_api_key\n    sensor:\n      &lt;&lt;sensor.ecovolter_boost_current&gt;&gt;\n      &lt;&lt;sensor.ecovolter_target_current&gt;&gt;\n      &lt;&lt;sensor.ecovolter_boost_time&gt;&gt;\n      ...\n    binary_sensor:\n      &lt;&lt;binary_sensor.ecovolter_single_phase&gt;&gt;\n      &lt;&lt;binary_sensor.ecovolter_charging_enabled&gt;&gt;\n      ...\n#+end_src\nYAML definitions of all sensors or binary sensors may appear anywhere in the source Org file. Each has to be designated by the same name that was used in the corresponding noweb reference (between the chevrons &lt;&lt; and &gt;&gt;). Here is an example:\n#+NAME: sensor.ecovolter_target_current\n#+begin_src yaml\n  - name: \"EcoVolter target current\"\n    unique_id: \"ccbfbac7-8eb3-4bb9-9951-4d41acfd5a1e\"\n    icon: \"mdi:car-electric\"\n    value_template: \"{{ value_json.targetCurrent }}\"\n    unit_of_measurement: \"A\"\n#+end_src\nWhen tangling the output YAML file, Emacs observes the indentation level of the noweb reference and indents the included chunk accordingly. The chunk itself thus needn’t be indented within it code block, which is very handy.\nThe noweb references may use any names, as long as they are unique, but I found it very convenient to use complete HA entity names because one can then immediately look up the entity in the graphical UI."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#deployment",
    "href": "posts/literate-ha-config/index.html#deployment",
    "title": "Literate Home Assistant Configuration",
    "section": "Deployment",
    "text": "Deployment\nIt’s nice to be able to generate all YAML configuration files from a single Org source, but by itself it isn’t sufficient. In order to make this system practical, I had to find a way for automating the process of deploying the generated files on my Home Assistant server. After some experimenting I ended up with the procedure described below. There can certainly be other ways of achieving the same but here I was able to leverage functionality already available in Git and Home Assistant.\nThe procedure consists of the following steps:\n\nEdit the source Org file Emacs.\nReview, stage and commit the changes to Git.\nPush the new commit(s) to a remote repository on my home network server.\nActivate the new configuration on the Home Assistant server, usually via quick reload.\n\nMost of of the underlying magic happens in step 3: the remote Git repository uses a pre-receive hook that does the following:\n\ncheck out the working tree on the remote server\nuse Emacs in the batch mode on it to tangle all YAML configuration files (still inside the working tree)\nuse rsync to synchronize modified YAML files with the config directory on my HA server.\n\nBelow is a transcript of the git push operation that also contains terminal output of the hook script (prefixed with remote:). A useful detail in the output of rsync is the list of YAML configuration files that have been updated – here it is just automations.yaml.\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 343 bytes | 343.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Already on 'master'\nremote: Loading /etc/emacs/site-start.d/00debian.el (source)...\nremote: Loading /etc/emacs/site-start.d/50autoconf.el (source)...\nremote: Tangled 36 code blocks from ll-ha-config.org\nremote: sending incremental file list\nremote: automations.yaml\nremote:\nremote: sent 45,826 bytes  received 47 bytes  30,582.00 bytes/sec\nremote: total size is 127,670  speedup is 2.78\nTo trail.lhotka.name:Depot/hazard\n   9f0eccf..8294a02  master -&gt; master\nThe hook script looks like this:\n  WDIR=\"/home/ha/literate-ha\"\n  ORG=\"ll-ha-config.org\"\n  read oldref newref refname\n  branch=$(basename $refname)\n  rm -rf $WDIR/*\n  git --work-tree=\"$WDIR\" checkout $branch -f\n  cd $WDIR\n  emacs --batch --eval \"\n      (progn\n        (setq org-id-track-globally nil)\n        (find-file \\\"$ORG\\\")\n        (org-babel-tangle))\"\n  rsync -crv --delete \\\n        --exclude 'ui_lovelace_minimalist/custom_*' \\\n        --exclude 'blueprints/automation/homeassistant' \\\n        --exclude 'blueprints/script/homeassistant' \\\n        --exclude 'blueprints/template/homeassistant' \\\n        --exclude 'esphome/trash' \\\n        --exclude 'esphome/.gitignore' \\\n        *.yaml esphome ui_lovelace_minimalist \\\n        custom_templates blueprints /mnt/ha"
  },
  {
    "objectID": "posts/literate-ha-config/index.html#code-organization",
    "href": "posts/literate-ha-config/index.html#code-organization",
    "title": "Literate Home Assistant Configuration",
    "section": "Code organization",
    "text": "Code organization\nAn outline of my HA literate configuration with all sections folded (collapsed) can be seen in Figure 1 (a):\n\n\n\n\n\n\n\n\n\n\n\n(a) Top-level outline\n\n\n\n\n\n\n\n\n\n\n\n(b) Skeletons of configuration files\n\n\n\n\n\n\n\nFigure 1: Screenshots of the literate configuration file in Emacs\n\n\n\nThe first section (shown partially unfolded in Figure 1 (b)) contains skeletons of most YAML configuration files that are generated from the master file. Their names are specified in the :tangle directive in the header of each code block. Most of the remaining sections then contain literate configuration organized by particular topics such as electricity costs (see Figure 2) or BEV charging.\n\n\n\n\n\n\nFigure 2: Example section in a literate configuration\n\n\n\nWhen searching for an existing definition of an automation, script, template sensor etc., I can either\n\nlook it up in the corresponding skeleton file by name and then easily navigate to its YAML definition using the command org-babel-goto-named-src-block (bound by default to Ctrl-C Ctrl-v g), or\nbrowse the appropriate section and find it in the text.\n\nThe IoT gadgets section contains descriptions of all smart devices (plugs, buttons, NFC tags etc.) that are in use. Other sections refer to them where needed, for example to document that an appliance is connected to or controlled by the device."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#literate-configuration-and-the-standard-ui",
    "href": "posts/literate-ha-config/index.html#literate-configuration-and-the-standard-ui",
    "title": "Literate Home Assistant Configuration",
    "section": "Literate configuration and the standard UI",
    "text": "Literate configuration and the standard UI\nThe standard web user interface of Home Assistant has been steadily improving and has become truly indispensable for certain kinds of tasks. Fortunately, dealing with configuration in the literate style (mostly) doesn’t mean that one has to avoid the standard UI as a configuration tool. On the contrary, both configuration approaches can be used in a synergy, one just has to be a little careful.\nFor example, when creating a new automation, I often start with the web UI and take advantage of autocompletion and other nice features of the web forms and widgets. After saving it, I copy and paste it to a code block in Emacs, make additional edits if necessary and finally commit and push the result to the Git repository. Similarly, it is quite convenient to develop a Jinja2 template in the web UI and then copy the final result to a code block in the Org file.\nWhen it comes to custom dashboards, I originally started with UI-Lovelace-Minimalist and had all its configuration in my Org file. It helped me a lot to keep the set of dashboards organized but it was still quite tedious to manage the entire user interface in source code. Not long ago I realized that I could no more ignore the vast improvements in the standard (Lovelace) dashboards and decided to migrate. Regrettably, there is this strict dichotomy of UI versus YAML modes for dashboard configuration. I chose the former because it is very convenient to lay out and update the dashboards via the graphical interface. Nonetheless, there are still situations where it would be more efficient to work with YAML code and literate configuration. In particular, I have separate dashboards for desktops, mobile devices and wall panels, so I quite often need to reuse same cards in different places. I can either configure them repeatedly via the UI, which is a drudgery for all but trivial cards, or copy and paste YAML code between web forms, which is difficult and error prone. I would thus very much appreciate to be able to work with YAML code and via UI interchangeably, as it is possible for scripts and automations.\nI do keep one dashboard in the YAML mode and work with it in the literate configuration style. It contains my collection of ApexCharts. The reason for this exception is twofold: first, ApexCharts have to be configured completely in YAML anyway, and, second, it is much easier to copy fragments of YAML code in Emacs (with adjusted indentation, if necessary) and paste them to other dashboards in UI mode."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#other-goodies",
    "href": "posts/literate-ha-config/index.html#other-goodies",
    "title": "Literate Home Assistant Configuration",
    "section": "Other goodies",
    "text": "Other goodies\nApart from the main features of Org and YAML modes that were described above, there are a few other useful functions.\nFirst, Emacs can help with generating unique IDs that are very important in Home Assistant. Whilst they aren’t required everywhere, I soon learnt to put them where possible (automations, template sensors etc.). It may seem logical to use descriptive strings as unique IDs, but as soon as one needs to change the underlying entity the previously assigned ID could become confusing if it no more reflects reality. Hence, a better practice is to use opaque strings, as Home Assistant does internally. Emacs can generate them with the uuidgen function, which I have bound to Ctrl-+ for easy access.\nOrg mode also offers extensive possibilities for exporting the source text in various formats. The HTML export might be useful for publishing a literate configuration (or parts thereof) as a web page. I personally don’t see much reason to publish my configuration in its entirety, as long as the resulting HTML doesn’t support collapsible sections in the same way as the Org source does. I occassionally use HTML export for publishing fragments dealing with specific topics. It is also very useful that GitHub now supports the Org mode syntax directly, so one can view nicely rendered literate configuration files out of the box. An example is here."
  },
  {
    "objectID": "posts/literate-ha-config/index.html#conclusions",
    "href": "posts/literate-ha-config/index.html#conclusions",
    "title": "Literate Home Assistant Configuration",
    "section": "Conclusions",
    "text": "Conclusions\nThe workflow for literate configuration that I described in the previous sections makes me feel confident that I am in control of my Home Assistant configuration. I can easily return to any topic even after a long break, refresh my understanding of how the relevant entities, automations and scripts are supposed to work together, and update or extend the configuration.\nBut – is this system for everybody? Objectively, it isn’t. For one, if you aren’t an Emacs user yet, it might not be very effective to learn the editor and the Org mode just for the sake of configuring Home Assistant. On the other hand, I do think that the Org mode is so powerful and useful that it is a reason good enough for starting with Emacs in the first place.\nSecond, the literate approach probably isn’t for someone who wants to get things done quickly. A literate configuration needn’t necessarily be a piece of art but it still requires certain extra effort and a bit of careful planning. For complex configurations, though, this overhead will pay off in a long term.\nAnd finally, I think beginners may be better off using the Home Assistant’s native UI that is more intuitive and provides contextual help in many places. It is possible to migrate configuration to the literate style at any later time."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html",
    "href": "posts/mybox-home-assistant/index.html",
    "title": "MyBox and Home Assistant",
    "section": "",
    "text": "MyBox is a line of sleek and smart BEV charging stations suitable for both home and public deployment. This post describes the steps necessary for integrating their Plus model (AC) into Home Assistant so that the wallbox can be monitored and controlled from this popular smart home platform.\nI use the MQTT messaging protocol for getting data from and sending commands to the wallbox. Modbus TCP could be another option in the future but, while listed in the datasheet, it is currently reserved only for internal use. According to the vendor, it should be made available to customers “soon”."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#mybox-plus",
    "href": "posts/mybox-home-assistant/index.html#mybox-plus",
    "title": "MyBox and Home Assistant",
    "section": "MyBox Plus",
    "text": "MyBox Plus\nWhy did I choose the MyBox platform in the first place? Well, although it is more expensive than some of the competing products, it offers a lot of useful functionality. Yet even more important for me was that the company seems to be aiming at technological innovations, so hopefully more exciting functionality will come later through software and/or hardware upgrades. One feature that I’d certainly love to try is V2H (vehicle-to-home) or V2G (vehicle-to-grid) as per ISO 15118.\nThe low-end MyBox Home model would most likely suffice for our home BEV charging purposes. After some hesitation, I decided to go for the Plus model, mainly because of its modularity. Should any hardware component need to be replaced or upgraded, it will be much easier and cheaper to do with a modular design.\n\n\n\n\n\n\n\n\n\n\n\n(a) Installation in our garage\n\n\n\n\n\n\n\n\n\n\n\n(b) Home screen of the app\n\n\n\n\n\n\n\nFigure 1: MyBox Plus wallbox and mobile application\n\n\n\nOn the other hand, since the wallbox was going to be installed in a locked garage, we didn’t need the optional RFID card reader. For the same reason I chose the tethered variant (with a fixed Type 2 cable), as it is much more convenient to simply take the cable off the holder and plug it into the car.\nFinally, I didn’t order the AC Sensor that can be used for adjusting wallbox charging power dynamically according to the current consumption of the household. My plan has been to implement such a control mechanism in Home Assistant, if it’s necessary at all."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#preliminaries",
    "href": "posts/mybox-home-assistant/index.html#preliminaries",
    "title": "MyBox and Home Assistant",
    "section": "Preliminaries",
    "text": "Preliminaries\nIn order to use MQTT in Home Assistant, MQTT integration needs to be added, and an MQTT broker also has to be set up. Actually, the latter is one of the extra functions implemented in the MyBox software, I haven’t tried it though. A natural choice for Home Assistant users is to use the Mosquitto broker add-on. Its installation and configuration is pretty straightforward, one just has to create a special Home Assistant account & password for use with the broker.\nAnother tool that I found quite handy is MQTT Explorer. It is an open-source MQTT client that makes it very easy (apart from other functions) to inspect MQTT data hierarchy. Some examples will be given below. MQTT Explorer is available for Windows, MacOS and Linux."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#enabling-mqtt-in-mybox",
    "href": "posts/mybox-home-assistant/index.html#enabling-mqtt-in-mybox",
    "title": "MyBox and Home Assistant",
    "section": "Enabling MQTT in MyBox",
    "text": "Enabling MQTT in MyBox\nThe local MQTT function isn’t turned on by default. To configure it, I first needed to obtain access to the MyBox cloud portal, where the configuration of the wallbox can be viewed and changed. I received the necessary credentials directly from the technician who did the wallbox installation.\nAfter logging into the portal and opening the device configuration, I scrolled down to the local_mqtt section, enabled it and filled in the parameters of my MQTT broker. The configured web form looks like this:\n\n\n\n\n\n\nFigure 2: MyBox portal\n\n\n\nThe two items that are masked out are the user name and password chosen for the Mosquitto broker user in Home Assistant. The local-mqtt-host parameter is the IP address of my Home Assistant server with Mosquitto broker. It is also necessary to configure the MQTT root topic. I chose charger, but anything reasonable can be used instead.\nIn my case, the Home Assistant server can be accessed only from the local network, so I don’t need encryption and certificates."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#verifying-the-communication",
    "href": "posts/mybox-home-assistant/index.html#verifying-the-communication",
    "title": "MyBox and Home Assistant",
    "section": "Verifying the communication",
    "text": "Verifying the communication\nFrom the configuration page of the MQTT integration in Home Assistant, I was able to view and change wallbox parameters via MQTT. For example, in the box Listen to a topic I could specify the topic\ncharger/e5qb-ekgg-48wz-o07w/ac-module-1-ac-module/max-charge-current\nand after pressing the START LISTENING button, the value of maximum charge current immediately popped up as seen in Figure 3 (a).\n\n\n\n\n\n\nImportant\n\n\n\nThe leftmost level in a topic (charger) is the root topic configured in the cloud portal (see above). Immediately following is the device ID of my wallbox that can also be found in the portal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Listening to an MQTT topic\n\n\n\n\n\n\n\n\n\n\n\n(b) Publishing an MQTT packet\n\n\n\n\n\n\n\nFigure 3: Testing MQTT in Home Assistant\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIt is also possible to dump all (a few dozen) parameters at once by using a wildcard topic with the hash symbol #, for example charger/#.\n\n\nSimilarly, I was able to change a writable parameter by sending a new value with /set appended to the corresponding topic name. An example for the max-charge-current parameter is in Figure 3 (b). In the MyBox mobile app (Figure 1 (b)) we can immediately verify that indeed the maximum charge current is now 6."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#configuring-home-assistant-sensors-and-scripts",
    "href": "posts/mybox-home-assistant/index.html#configuring-home-assistant-sensors-and-scripts",
    "title": "MyBox and Home Assistant",
    "section": "Configuring Home Assistant sensors and scripts",
    "text": "Configuring Home Assistant sensors and scripts\nWith MQTT properly working, I used MQTT Explorer for connecting to the Mosquitto broker running on my Home Assistant server, and started browsing the MQTT tree of the wallbox. I then selected topics from the following two subtrees (both with the charger/e5qb-ekgg-48wz-o07w/ prefix) for defining Home Assistant sensors and scripts, namely\n\nac-module-1-ac-module – status and charging-related settings of the wallbox, see Figure 4 (a).\nac-module-1-ev-meter – data about power output and energy consumption, see Figure 4 (b).\n\n\n\n\n\n\n\n\n\n\n\n\n(a) ac-module-1-ac-module subtree\n\n\n\n\n\n\n\n\n\n\n\n(b) ac-module-1-ev-meter subtree\n\n\n\n\n\n\n\nFigure 4: Topics in MQTT Explorer\n\n\n\nHome Assistant sensors and binary sensors that monitor specific MQTT topics are defined in the mqtt section of Home Assistant configuration. I have them in a separate file mqtt.yaml, which is included in the main configuration file:\n\n\nconfiguration.yaml\n\nmqtt: !include mqtt.yaml\n\nSensors are configured in the sensor subsection. For instance, the sensor for maximum charge current is defined as follows:\n\n\nmqtt.yaml\n\nsensor:\n  - name: \"MyBox max charge current\"\n    icon: \"mdi:current-ac\"\n    unique_id: \"e7446234-e557-4135-9117-3b9b6db3c0df\"\n    unit_of_measurement: \"A\"\n    state_class: measurement\n    state_topic: &gt;-\n      charger/e5qb-ekgg-48wz-o07w/ac-module-1-ac-module/max-charge-current\n\nSimilarly, binary sensors appear in the binary_sensor subsection, for example\n\n\nmqtt.yaml\n\nbinary_sensor:\n  - name: \"MyBox cable locked\"\n    icon: \"mdi:ev-plug-type2\"\n    unique_id: \"f010644a-8e6f-4811-94b1-7a75fa05f7d2\"\n    state_topic: &gt;-\n      charger/e5qb-ekgg-48wz-o07w/ac-module-1-ac-module/cable-locked\n    payload_on: \"true\"\n    payload_off: \"false\"\n\nScripts can be used for implementing various actions such as changing a parameter value or pausing/resuming/stopping a charging session. This script changes the value of maximum charge current:\n\n\nscripts.yaml\n\nmybox_set_max_charge_current:\n  alias: \"Set the maximum charge current\"\n  description: &gt;-\n    Set the maximum charge current for MyBox.\n  icon: \"mdi:current-ac\"\n  fields:\n    value:\n      name: \"Max charge current value\"\n      selector:\n        number:\n          min: 6\n          max: 16\n          step: 1\n          unit_of_measurement: \"A\"\n          mode: slider\n  sequence:\n    - action: mqtt.publish\n      data:\n        topic: &gt;-\n          charger/e5qb-ekgg-48wz-o07w/ac-module-1-ac-module/max-charge-current/set\n        payload_template: \"{{ value }}\"\n\nAnd the following script pauses the charging session:\n\n\nmqtt.yaml\n\nmybox_pause_charging:\n  alias: \"Pause charging\"\n  description: &gt;-\n    Pause EV charging from MyBox.\n  mode: single\n  sequence:\n    - action: mqtt.publish\n      data:\n        topic: &gt;-\n          charger/e5qb-ekgg-48wz-o07w/ac-module-1-ac-module/pause-charging/set\n\nComplete contents of configuration files that I currently use for MyBox can be downloaded from GitHub."
  },
  {
    "objectID": "posts/mybox-home-assistant/index.html#conclusions",
    "href": "posts/mybox-home-assistant/index.html#conclusions",
    "title": "MyBox and Home Assistant",
    "section": "Conclusions",
    "text": "Conclusions\nMyBox Plus is a nice piece of hardware with rich software functionality. I’ve been using it regularly for overnight charging at 11 kW (the wallbox supports up to 22 kW) with no issues whatsoever.\nMy only complaint is that I cannot enforce single-phase operation: if a car has a three-phase onboard charger, then MyBox will feed it over three phases. This doesn’t look like a limitation, but it prevents me from using MyBox in the mode of using only excess energy from our photovoltaic system – its minimum charging power is 4.1 kW (3 × 6 A), which is very close to the peak PV production at optimal conditions, so there is essentially no space for power regulation. Therefore, I ended up using my older EcoVolter portable wallbox for excess-energy charging because it can be switched to single-phase operation and thus go with the charging power down to 1.4 kW (1 × 6 A). I plan to write another blog post about integrating this wallbox to Home Assistant and using it in the excess-energy mode.\nBut back to MyBox: integrating it to Home Assistant via MQTT and YAML configuration turned out to be pretty easy and perfectly sufficient for our purposes. It might make sense to write a full-fledged HA integration in Python, but I guess I am not in the right position to do it, as I don’t have some of the interesting hardware modules (RFID card reader, AC sensor) and don’t use any security-related functions. Potential developers of such an integration would also appreciate more extensive technical documentation, which is currently rather scarce.\nAcknowledgment: I am grateful to Tomáš Kada, product specialist at MyBox, who helped me with setting up MQTT and promptly responded to all questions that I had."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ladislav Lhotka’s Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nLiterate Home Assistant Configuration\n\n\n\nOrg mode\n\nliterate programming\n\nHome Assistant\n\n\n\nLarger instalations of Home Assistant smart-home networks usually lead to a fairly complex configuration that is difficult to develop and maintain. This blog post describes my system of HA YAML code management, documentation and deployment based on Git, Emacs editor with its Org mode, an principles of literate programming.\n\n\n\n\n\nMay 5, 2025\n\n12 min\n\n\n\n\n\n\n\n\n\n\n\nMyBox and Home Assistant\n\n\n\nelectromobility\n\nHome Assistant\n\n\n\nThis post describes how to integrate MyBox wallbox to Home Assistant via MQTT.\n\n\n\n\n\nOct 29, 2024\n\n8 min\n\n\n\n\nNo matching items"
  }
]